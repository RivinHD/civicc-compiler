# CivicC Compiler
This repository was created as part of the **Compiler Construction** lecture at Friedrich Schiller 
University Jena during the winter term 2025.
With this compiler we support the CivicC language, which is reduced C-like toy language the understand
and develop the basic functionality of a Compiler. For the development we leverage the 
[Coconut Framework](https://github.com/CoCoNut-UvA/coconut), which generates based on an own 
[DSL](https://coconut-uva.github.io/coconut/dsl_syntax.html) a specific AST. Different passes can then
be used to generate, optimize, or even print the AST.

## Requierements
The full dependencies of CoCoNut are listed on the [Coconut](https://github.com/CoCoNut-UvA/coconut)
repository. 

**Supported Systems:** Linux, macOS

### Linux

On Ubuntu the requirements can be install with:
```bash
sudo apt update && sudo apt install build-essential cmake bison flex graphviz
```
For macOS, see [macOS dependencies](#macos-dependencies).

## macOS 
The following build dependencies are required on macOS:
```bash
brew install cmake coreutils binutils bison graphviz gnu-tar
```

You might also need to run the following for CMake to find Bison:
```bash
echo "export PATH=\"$(brew --prefix)/opt/bison/bin:\$PATH\"" >> ~/.zshrc
```

**Note:** Make sure to fully restart your terminal after adding this line to `.zshrc`, and 
delete the folder `build` if it exists. Otherwise, CMake will keep using the old unsupported Bison 
version that macOS ships with.

## Building the Project
First clone this repository:
```
git clone https://github.com/RivinHD/civicc-compiler.git
```

Next CMake is used to build this Project.
You can use the following command to configure and build the project into the `build` folder.
```
cmake -B build && cmake --build build -j <jobs>
```

In addition a compact command is provided with the `Makefile`.
The debug version of the project is build by running.
```
make
```

Further a release version can be build with:
```
make release
```

For further information and additional targets run: 
```
make help
```


## VS Code support
For syntax highlighting of the CoCoNut DSL files (e.g. the `main.ccn` file), you can install the 
[nutcracker](https://github.com/CoCoNut-UvA/nutcracker/) extension from the Visual Studio Marketplace 
[here](https://marketplace.visualstudio.com/items?itemName=CoCoNut-UvA.nutcracker).

We provide a Linux configuration file in [`.vscode/c_cpp_properties.json`](.vscode/c_cpp_properties.json) 
that helps IntelliSense to find the header files generated by cocogen.
VS Code should pick this up automatically; if you open a C file you should see CoCoNut-Linux in 
the bottom-right corner.

## Creating an archive
You can quickly create an archive for submitting to canvas as follows
```bash
make dist
```
This gets everything in your git repo and combines it with the used coconut version in one archive.
This should contain everything needed to hand in your assignments.
**NOTE:** Always check the resulting archive if it contains everything and builds correctly.

## Grammar Generator
The project includes a [grammar generator and mutator](https://github.com/AFLplusplus/Grammar-Mutator/tree/stable)
that is used for the fuzzing with [AFL++](https://github.com/AFLplusplus/AFLplusplus/tree/stable),
but can also be used independently
to generate CivicC source files.

The grammar is defined in JSON format and is located at `grammars/civicc.json`.

To build the generator use the CMake option `-DBUILD_GRAMMAR_GENERATOR=1` or run: 
```
make grammar_generator.
```

To build CivicC files with the generator you run (the seed is optional):
```
./build/grammar_generator-civicc <max_num> <max_size> <output_dir> <tree_output_dir> [<random_seed>]
```
e.g. for 100 CivicC files with a max size of 1000 i.e. grammar resolution will be put into the 
`output` directory. The trees are only need for fuzzing and thus are discard.
```
./build/grammar_generator-civicc 100 1000 ./output /dev/null
```


## Fuzzing
The project support fuzz testing with [AFL++](https://github.com/AFLplusplus/AFLplusplus/tree/stable)
(Commit Hash: `68b492b2c7725816068718ef9437b72b40e67519`).
Therefore, the [afl-clang-lto](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.lto.md)
compiler need to be installed on your system. 

### Risks of Fuzzing
*NOTE: Before you start, please read about the
[common sense risks of fuzzing](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#0-common-sense-risks).*

### Installation 

Follow the [installation instruction](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md)
listed on AFL GitHub page for your system as a reference.
We will not need the complete feature set of AFL therefore it is good enough to only install some 
dependencies.

For this project we do not need binary-fuzzing. Thus, we only need the dependencies to build the 
`afl-clang-lto` compiler.
These are all dependencies listed on the first line and second line of the [installation instruction](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md).
Mostly LLVM will be leveraged, use the newest version that is available to you. 

Now we are ready to download and build AFL.

1. Download AFL:
    ```
    git clone https://github.com/AFLplusplus/AFLplusplus
    ```
2. Initialize Submodules:
    ```
    cd AFLplusplus
    git submodule update --init
    ```
3. Building AFL: (We only need source code fuzzing, thus we use `source-only`)
    ```
    CC=clang CCX=clang make PERFORMANCE=1 source-only
    ```
    Using clang as compiler is not required, but will compile better code as LLVM has more
    sophisticated optimizations.
    The `PERFORMANCE=1` option will lead to a more optimize built for your system, see 
    [installation instruction](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md)
    (not supported on macOS)
4. Install AFL: (default path are your `/usr/local` folders, you can set a different directory with `--prefix <directory>`)
    ```
    sudo make install
    ```

We also use Grammar Fuzzing with [AFL Grammar Mutator](https://github.com/AFLplusplus/Grammar-Mutator).
Therefore also need the dependencies list their.

The `atnlr-4.8-complete.jar` will be automatically download in placed in the Grammar Mutator library
by our `CMakeLists.txt`.

### Further recommended setup steps (optional)

Fuzzing has some risk on your system, you should have already read about them in the
[0. Common sense risk](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#0-common-sense-risks).

The mitigate the physical I/O risk, we can write to a filesystem that lives on the RAM, also known
as `ramdisk` or `tmpfs`. 
This is exactly what AFL recommends in their 
[Fuzzing in Depth](https://aflplus.plus/docs/fuzzing_in_depth/) documentation.
Therefore, we will mount a `tmpfs` for our own usage and anytime AFL is called we will use the 
`AFL_TMPDIR` flag to tell AFL were to write data if needed:
1. Create an empty directory to mount to:
    ```
    mkdir /mnt/tmpfs
    ```
2. Mount the directory:
    ```
    mount -t tmpfs -o size=16G tmpfs /mnt/tmpfs/
    ```
    Here we have a limit of 16 gigabytes of ram to use for our ram filesystem.


### Start Fuzzing

Before running a fuzz test you should run: 
```
sudo afl-sytem-config
```
This will reconfigure your system for more fuzzing performance.\
*NOTE:* These changes will reduce the security of the system!\
But these are none-persistent changes and will be reset after system is rebooted.

Now you can run the fuzzer with:
```
make fuzz_<target>
```

The following targets are available:
- `civicc`: Fuzz the complete compiler
- `civicc_grammer`: Fuzz the complete compiler
- `scanparse`: Fuzz the scanner and parser only
- `scanparse_grammer`: Fuzz only the positive space of the scanner and parser i.e. grammar valid CivicC code.

*Note:* Keeping the fuzz target/slice smaller is more efficient.

#### Multicore fuzzing

The fuzz on multiple cores, you can set the flag `FUZZ_CORES=<Cores>` on any fuzz target.
This will start the amount of fuzzer with the name `fuzzer<i>` in separate tmux sessions that sync 
on the same directory.
We use tmux here to run them in individual terminals, thus `tmux` is an **additional dependency** when 
fuzzing on multiple cores.
Also see [AFL++ Documentation - Using Multiple Cores](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-using-multiple-cores).

If `FUZZ_CORES=0` is set, the core count of the system is used.\
Note: The fuzzing session **without** the `FUZZ_CORES` argument will only use a single core and will not be started in a tmux session. 
You can use `FUZZ_CORES=1` to run a single core fuzzing session in tmux.

For example, you can run multicore fuzzing on automatic core count with:
```
make fuzz_<target> FUZZ_CORES=0
```

To clean up all tmux sessions of the fuzzer and stop the multicore fuzzing you can run:
```
make kill_fuzzer_sessions 
```
