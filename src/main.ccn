start phase RootPhase {
    info = "Denotes the entry point of your compiler",

    actions {
        pass SPdoScanParse;
        ContextAnalysis;
        CodeGenPreparation;
        Optimization;
        CodeGen;
        FreeSymbols;
    }
};

traversal Print {
    uid = PRT
};

cycle Optimization {
    actions {
        traversal AlgebraicSimplification {
            uid = OPT_AS,
            nodes = {
                Program,
                Binop,
                Monop,
                ProcCall,
                FunDef,
                Cast,
                Ternary
            }
        };
        traversal AlgebraicReordering {
            uid = OPT_AR,
            nodes = {
                Binop
            }
        };
        traversal ConstantFolding {
            uid = OPT_CF,
            nodes = {
                Program,
                Binop,
                Ternary
            }
        };
        traversal BranchEvaluation { // Optimize branching decision on constant values
            uid = OPT_BE,
            nodes = {
                IfStatement,
                Ternary,
                WhileLoop,
                ForLoop,
                DoWhileLoop,
                Statements,
                Program,
                FunDef, 
                Assign
            }
        };
        traversal DeadCodeElimination {
            uid = OPT_DCE,
            nodes = {
                Program,
                Fundef,
                Funbody,
                Declarations,
                LocalFunDefs,
                VarDecs,
                Statements,
                Var,
                Assign,
                ProcCall,
                DoWhileLoop,
                ArrayAssign,
                ForLoop,
                WhileLoop,
                IfStatement,
                Ternary
            }
        };
    }
};

phase ContextAnalysis {
    actions {
        traversal ExtractForIterator {
            uid = CA_EFI,
            nodes = {
                FunDef,
                VarDecs,
                ForLoop,
                Var,
                Program
            }
        };
        traversal FunctionHeader {
            uid = CA_FH,
            nodes = {
                Program,
                FunDef,
                FunDec
            } 
        };
        traversal DeclarationCheck {
            uid = CA_DC,
            nodes = {
                Program,
                // Process all Global variables before the function, as the scoping rules say:
                // Functions can access global variables defined before and after the function
                Declarations, 

                // Declarations
                GlobalDec,
                VarDec,
                Params,
                FunDef,
                FunDec,


                // Usage
                ArrayExpr,
                Var,
                ProcCall,

                // Edge
                DimensionVars // No need to check array var as they are defined implicitly
            } 
        };
        traversal TypeChecking {
            uid = CA_TC,
            nodes = {
                Program,

                // Assignments
                GlobalDec,
                VarDec,
                FunDef, // Return type
                Assign,
                ArrayAssign,
                ForLoop,
                DoWhileLoop,
                WhileLoop,
                IfStatement,

                // Usage
                ArrayExpr,
                Var,
                ProcCall,
                Cast,
                Int,
                Float,
                Bool,
                Binop,
                Monop,
                RetStatement,

                // Edge
                ArrayVar, // need to type check the dims as they are not user defined.
                FunDec // no need to check function. 
            }
        };
    }
};

phase CodeGenPreparation
{
    actions {
        traversal InitFunction {
            uid = CGP_IF,
            nodes = {
                Program,
                GlobalDef
            }
        };
        traversal HeterogeneousAssignments {
            uid = CGP_AA,
            nodes = {
                // Symbol Table - Array Assign
                Program,
                FunDef,

                // Edge Case
                Globaldef, // exported array always need var dims

                // Nodes to update
                Funbody,
                ArrayExpr,
                VarDecs,
                ForLoop,
                Statements,
                Declarations
            }
        };
        traversal HomogeneousAssignments {
            uid = CGP_HA,
            nodes = {
                // For __init function
                Program,
                FunDef,

                // Nodes to update
                Funbody,
                VarDec,
                VarDecs
            }
        };
        traversal ToTernary {
            uid = CGP_TT,
            nodes = {
                Binop,
                Cast
            }
        };
        traversal ParameterPassing {
            uid = CGP_PP,
            nodes = {
                Program,

                // Nodes to update
                FunDef,
                FunHeader,
                ProcCall
            }
        };
        traversal DimensionReduction {
            uid = CGP_DR,
            nodes = {
                // Symbol Table - Array Assign
                Program,
                FunDef,

                // Nodes to update
                ArrayExpr
            }
        };
    }
};

phase CodeGen {
    actions {
        traversal CodeGeneration {
            uid = CG_CG
        };
    }
};

traversal FreeSymbols {
    uid = FS,
    nodes = {
        Program,
        FunDef
    }
};

/*** AST ***/

/**********************/
/* Enums **************/
/**********************/

enum MonOpType {
    prefix = MO,
    values {
        not, neg
    }
};

enum BinOpType {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

enum DataType {
    prefix = DT,
    values {
        void, bool, int, float
    }
};

/**********************/
/* Nodesets ***********/
/**********************/

nodeset Expr = {Ternary, Binop, Monop, Cast, ProcCall, Var, ArrayExpr, Int, Float, Bool, Pop};
nodeset Statement = {Assign, ProcCall, IfStatement, WhileLoop, DoWhileLoop, ForLoop, RetStatement, ArrayAssign};
nodeset Declaration = {FunDec, FunDef, GlobalDec, GlobalDef};
nodeset VarOptArrayVar = {Var, ArrayVar};
nodeset VarOptArrayExpr = {Var, ArrayExpr};
nodeset ExprOptArrayInit = Expr | {ArrayInit};

/**********************/
/* Nodes **************/
/**********************/

root node Program {
    children {
        Declarations decls { constructor, mandatory }
    },

    attributes {
        user htable_stptr symbols
    }
};

node Declarations {
    children {
        Declaration decl { constructor, mandatory },
        Declarations next { constructor }
    }
};

node FunDec {  // implicitly conditions the 'extern' attribute
    children {
        FunHeader funHeader { constructor, mandatory }
    }
};

node FunDef {
    children {
        FunHeader funHeader { constructor, mandatory },
        FunBody funBody { constructor, mandatory }
    },

    attributes {
        bool has_export { constructor },                       // if exists, has to be 'export'
        user htable_stptr symbols
    }
};

node GlobalDec {  // implicitly conditions the 'extern' attribute
    children {
        VarOptArrayVar var { constructor, mandatory } 
    },

    attributes {
        DataType type { constructor }  // mandatory
    }
};

node GlobalDef { 
    children {
        VarDec varDec { constructor, mandatory }
    },

    attributes {
        bool has_export { constructor }                       // if exists, has to be 'export'
    }
};

node FunHeader {
    children {
        Var var { constructor, mandatory },
        Params params { constructor }
    },

    attributes {
        DataType type { constructor } // mandatory
    }
};

node Params {
    children {
        VarOptArrayVar var { constructor, mandatory },
        Params next { constructor }
    },

    attributes {
       DataType type { constructor } // mandatory 
    }
};

node FunBody {
    children {
        VarDecs varDecs { constructor },
        LocalFunDefs localFunDefs { constructor },      // Extension 1
        Statements stmts { constructor }
    }
};

node VarDecs {
    children {
        VarDec varDec { constructor, mandatory },
        VarDecs next { constructor }
    }
};

// Extension 1
node LocalFunDefs {
    children {
        FunDef localFunDef { constructor, mandatory },
        LocalFunDefs next { constructor }
    }
};

node Statements {
    children {
        Statement stmt { constructor, mandatory },
        Statements next { constructor }
    }
};

node Assign {                                   // Id = Expr
    children {
        Var var { constructor, mandatory },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    },

    attributes {
        BinOpType op { constructor },  // mandatory not possible, but required for construction
        DataType argtype { constructor } // type of the children
    }
};

node Ternary {
    children {
        Expr pred { constructor, mandatory },
        Expr ptrue { constructor, mandatory },
        Expr pfalse { constructor, mandatory }
    }
};

node Monop {
    children {
        Expr left { constructor, mandatory }
    },

    attributes {
        MonOpType op { constructor }  // mandatory not possible, but required for construction
    }
};

node VarDec {
    children {
        VarOptArrayExpr var { constructor, mandatory },
        ExprOptArrayInit expr { constructor }
    },

    attributes {
        DataType type { constructor } // mandatory
    }
};

node ProcCall {
    children {
        Var var { constructor, mandatory },
        Exprs exprs { constructor }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

node IfStatement {
    children {
        Expr expr { constructor, mandatory },
        Statements block { constructor },
        Statements else_block { constructor }
    }
};


node WhileLoop {
    children {
        Expr expr { constructor, mandatory },
        Statements block { constructor }
    }
};

node DoWhileLoop {
    children {
        Statements block { constructor },
        Expr expr { constructor, mandatory }
    }
};

node ForLoop {
    children {
        Assign assign { constructor, mandatory },
        Expr cond { constructor, mandatory },
        Expr iter { constructor },
        Statements block { constructor }
    }
};

node RetStatement {
    children {
        Expr expr { constructor }
    }
};

// ( DataType ) Expr
node Cast {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        DataType type { constructor }, // mandatory
        DataType fromtype { constructor } // defined by type checking
    }
};

node Var {
    attributes {
        string name { constructor, mandatory }
    }
};

node ArrayVar {
    children {
        DimensionVars dims { constructor, mandatory },
        Var var { constructor, mandatory }
    }
};

node DimensionVars {
    children {
        Var dim { constructor, mandatory },
        DimensionVars next { constructor }
    }
};

node ArrayExpr {
    children {
        Exprs dims { constructor, mandatory },
        Var var { constructor, mandatory }
    }
};

node ArrayInit {
    children {
        ExprOptArrayInit expr { constructor, mandatory },
        ArrayInit next { constructor }
    }
};

node ArrayAssign {
    children {
        ArrayExpr var { constructor, mandatory },
        Expr expr { constructor, mandatory }
    }
};

node Int {
    attributes {
        int val { constructor }  // mandatory
    }
};

node Float {
    attributes {
        double val { constructor }  // mandatory
    }
};

node Bool {
    attributes {
        bool val { constructor }  // mandatory
    }
};

// Pops a proccall element from the stack and loads the replacement value
node Pop {
    children {
        Expr expr { constructor, mandatory },
        Expr replace { constructor } 
    },

    attributes {
        // The type of the pop expression
        DataType type { constructor }, // mandatory
        bool replace_before_pop { constructor } // mandatory
    }
};
